# The Pragmatic Programmer

## 개요
- 노마드코더에서 함께 진행한 책읽기 (TIL)
- 2022.03.19 ~ 
- 

## Table of Contents

> [#1 서문 ~ 1장](#20220319-til)

> [#2 2장](#20220321-til)

> [#3 다른 TIL 읽어보기](#20220322-til)

> [#4 3장](#20220323-til)

> [#5 4장](#20220324-til)

- 그 사이에 퀴즈가 있었던거 같은데, 항목으로 정리하는걸 잊었다.

> [#6 5장](#20220326-til)

> [#7 몇가지 연습문제](#20220328-til)

---
## 2022.03.19 TIL
- 서문 ~ 1장 실용주의 철학 

### 책에서 기억하고 싶은 내용 & 메모

> 왜 코드가 메리의 컴퓨터에서만 빌드되는 거죠?(2판 서문)

- 세상은 넓고 지구는 공평했다. 왜 모두 같은 고민을 하는 거죠? 하며 되묻고 싶은 장면인데. 사실 jdk라는 이름에 맞게 ci/cd툴도 함께 공급(?) 되는게 맞지 않나 싶긴하다. github도 ms에서 인수한 마당에.

<br/>

> 여러분은 매일 작은 기적을 만드는 것이다. 참 어려운 직업이다. (1판 서문)

- 작업에 대한 안내, 사용자를 고려한 설계, 프로젝트 일정 준수 등. 모든 애환이 여기 엿보인다.

<br/>

> 당신은 당신의 조직을 바꾸거나, 당신의 조직을 바꿀 수 있다. (3p)

- 일단 새겨두자. 원격 근무가 안된다면 다른 곳을 가라는 글도 눈에 띈다. 메모.

<br/>

> 소프트웨어 엔트로피
<br/>

> - 깨진 창문을 내버려 두지 말라

- 왜 쿼리를 이렇게 구성해놨는지, 프런트 소스는 왜 항상 미묘하게 차이나는 템플릿을 프로젝트 착수시기마다 버전을 다르게 불러오는건지, 궁금하곤 했다. 하나씩 보자마자 고쳐나가야지.

<br/>

> 시작 피로 (start-up fatigue)

- 프로젝트 하나 하기까지, 그리고 종료하기까지 필요한 코스트가 크긴 하다. 협업 요청보다 절차의 간소화를 요청해야겠다.

<br/>

> 오늘의 훌륭한 소프트웨어는 많은 경우 환상에 불과한 내일의 완벽한 소프트웨어보다 낫다 (17p)

- TDD의 개발 순서, agile에서 가장 간단한 프로토타입부터 하나씩 고도화 해나가는 맥락을 보는듯하다. 모든 프로그래머들이 같은 이야기를 하는 데에는 이유가 있겠지.

<br/>

> 기능 블로트 : 소프트웨어가 쓰는 기능에 비해 많은 기능을 가지고 있고, 그에 따라 버그나 취약점이 생길 가능성이 높아지는 것

<br/>

> 목표 :
> - 매년 새로운 언어를 최소 하나는 배워라
> - 기술 서적을 한 달에 한 권씩 읽어라
> - 수업을 들어라
> - 지역 사용자 단체나 모임에 참여하라

- 언어 학습이나 기술 서적에 다소 부족함이 있었는데, 분발해야겠다.
- 지역 사용자 단체..는 웹으로 대체 가능한거겠지? 그래도 주말에 간소히 모여서 소규모 프로젝트를 하는 집단은 필요한 느낌이다.

<br/>

> Five Whys.

- 이걸 여기서 또 보네. 햄버거 하면 Five guys인데.

<br/><br/>

### 오늘 읽어본 다른 사람의 TIL

- 1장 : https://velog.io/@ohdowon064/%EB%85%B8%EA%B0%9C%EB%B9%84-pragmatic-1%EC%9E%A5.-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EC%B2%A0%ED%95%99
  - 책임감 중요하지. 암암.

- 1장 : https://proamateur92.tistory.com/68
  - 커뮤니케이션 방식에 대한 고민선이 같았다...! 실무자의 그 무언가가 느껴진다.

<br/>

### 결론 - 오늘의 소감
<details>
  <summary> 햄버거는 five guys, 방법론은 five whys. </summary>
  
  - 우리는 왜 회사의 IT 부서와 IT 회사간의 차이와 벽을 느끼는지 디테일이 보이는 대목들이었다.
  
  - 개발자라는 특정 직업군의 한 끝단에서 머무르는게 아니라, 프로젝트의 관리자로서 마음가짐을 엿보게 해주는 느낌. 
  
  - 클린 코드보다는 조금 더 사회생활 풀이 같긴 한데, 아직 일련의 불안함이 앞선다. 이 책이 나에게 도움이 될까, 내 부서의 다른 사람들에게 도움이 될까.
  
  - 햄버거는 five guys, 방법론은 five whys. 그런데 six sigma 시대의 방법론 아닌가 걱정은 살짝 된다만서도.
  
</details>
<br/>
<br/>

---
## 2022.03.21 TIL
- 2장 실용주의 

### 책에서 기억하고 싶은 내용 & 메모

> 좋은 설계는 나쁜 설계보다 바꾸기 쉽다. (...) 그래서 우리는 ETC 원칙을 따른다. Easier to Change. 

- 어떤 설계가 보다 뛰어난가는 바꾸기 쉬움에 있었다. 클린코드에서 코드 가독성, 응집도를 낮춰서 biz변경시의 유연한 대응과 맥이 닿는 부분.

<br/>

> DRY 원칙은 다음과 같다. `모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.` Don't Repeat Yourself

- 권위 있게라는 표현이 참신했다. 그만큼 해당 코드에 대해 깊이 고민하고 반영하라는 취지 아닐까.

<br/>

> 이제 숫자 형식을 바꿔야 하면 format_amount를 바꾸면 되고, 항목 이름 형식을 바꾸고 싶으면 report_line을 바꾸면 된다.

```c++
def format_amount(value)
  result = sprintf("%10.2f".value.abs)
  if value <0
    result + "-"
  else
    result + " "
  end
end

def print_line(label, value)
  printf "%-9s%s\n", label, value
end

def report_line(label, amount)
  print_line(label + ":", format_amount(amount))
end

def print_balance(account)
  report_line("Debits", account.debits)
  report_line("Credits", account.credits)
  report_line("Fees", account.fees)
  print_line("", "---------")
  report_line("Balance, account.balance)
end
```

- cleancode에서는 책의 예제와 같은 작위적인 포맷-라인정렬이 구닥다리- 본문은 account.{methods}를 탭으로 정렬함 - 라고 하긴 했는데, 그래도 코드에서 중복을 줄이는 발상이 인상 깊었다.

- 하지만 코드가 좀 장황해지지 않나 생각은 든다. 첫 코드는 순차적으로 이런 동작들을 하겠구나 읽혔다면, 마지막 코드는 각각의 함수가 어디에서 쓰이지 하고 지면을 오가며 읽어야하는 불편함이 있다. 만약 Java였다면 선언부와 사용부를 도치시켜서 조금 더 가독성이 좋았을지도 모르겠다.

- 혹은 account라는 객체 정의 > account.print_balance(format) 정도로 재구성하는게 좋지 않을까? 

<br/>

> 모든 코드 중복이 지식의 중복은 아니다.

- 이어나온 사례에서 validate(args) 로 구성하면 어떨까 싶었는데, 다시 validate에서 age인지 quantity인지 확인하고 각각 함수를 작성해줘야 하는 점을 간과했었다.

- 그렇다고 args.validate와 같이 구성하면, 객체 마다 validate를 정의해야하니.. args를 interface또는 추상클래스로 만들어서 validate를 재정의하게 해야하는데, 무엇이 ETC에 적합한지는 모호하다고 생각한다. 아직은 규모가 작으니 독립적인 두 개의 메소드로 구현하는게 맞을지도?

<br/>

> 개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다.

- 어느 정도의 부분에서 중복으로 인한 비용 < 개발자간 소통비용이 되어 중복이 용인되는걸까? 정산에서 자릿수 검증과 기온 체크에서 자릿수 검증은 같은 모듈을 써야하나?

<br/>

> 컴포넌트들이 각기 격리 되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다

- 단일 책임 원칙과 맥이 닿는 부분으로 이해된다.

<br/>

> 다중 상속과 다중 인터페이스 사용이 직교성에 끼치는 영향이 다른가?

- 오버라이딩 관점에서 다중 인터페이스를 우려한 글은 보았는데, 쉽지 않다. 다른가?

<br/>

> 외부의 API를 여러분이 만든 추상화 계층 뒤로 숨겨라

- DB Connection도 한층 추상화하고 도메인 언어를 만든 것을 생각하면, 이게 맞는 방향으로 생각된다. 장황하지 않은가는 그 뒤의 문제 아닐까.

<br/>


> 사업 부서 사람들은 달성하려는 목표에 대해 두루뭉술한 생각만 갖고 있을 뿐, 세부사항에 대해서는 알지도 못하고 신경도 안 쓴다.

- 이걸 마음에 새겨 두자. 모르니까 소통이 안되는 것이고, 우리의 가치는 여기에 형태를 부여하는 것이었다.

<br/>


> 추정치는 어디에서 나오는가? (...) 이미 그 일을 해본 사람에게 물어보라

- 생각보다 멀쩡한 개발자로 살아남으려면 개인간의 커넥션이 중요했다. 앞에서는 끈끈한 팀, 뒤에서는 이미 그 일을 해본 사람.

<br/>

> 누군가 추정해 달라고 하면 뭐라고 대답해야 할까? 나중에 연락드릴게요. 라고 말해야 한다.

- 수평적이고 소통이 빠른 회사에서 생각되는 가장 이상적인 시나리오인 것 같다. 물론 담당자가 급하다고 이상한 추정치를 내면, 2주 뒤 임원보고 까지 올라가 있는 자신의 추정치를 볼 수 있긴 하지만.


<br/><br/>

### 오늘 읽어본 다른 사람의 TIL

- 2장. [이민호님의 노션](https://minosssss.notion.site/TIL-DAY2-3-aa05433c3ef3406db2ab71c60a56112b)
  - 계획없이 코딩 말자는 격언이 인상적이다. 외부 API호출은 한번 감싸라는 말이 불현듯 뇌에 스친다.



<br/><br/>

### 결론 - 오늘의 소감
<details>
  <summary> ETC : Easier to Change </summary>

  - 개방-폐쇄 원칙과 충돌하나 오해했지만, ETC라는 가치 기준을 잘 따라가는, 구현하는 방식이 Open-close Principle 이라고 결론 내렸다. 가장 쉬운 방식의 기능변경이 가능한 코드는, 모듈화가 잘되어 새로 추가만 하면 되는 코드였다.
  
  - 끈끈한 개발자 팀은 정말 쉽지 않아 보인다. 내가 쓴 코드를 자신있게 오픈하는 문화가, 기업의 회사원으로서의 문화와는 충돌할 수 있지 않나? 프로젝트 사서는 조금 더 실용적인 아이디어로 보이지만, 명칭이 아닌 실제 역할로 이어지기에는 시간이 필요해보인다.
  
  - 내 소스를 자유롭게 올리고 리뷰 받는 것과, 팀 내에 이미 그 일을 해본 사람에게 물어보고 추정치를 내리는 것에는 긴 간극이 있다. 요즘은 개발 마저 인싸가 가져가는 시대인가? 어렵다.
  
  - 종반으로 갈수록 개발자 보다는 프로젝트의 관리자나 리더, 혹은 그 사이에 있는 이들을 위한 방법론으로 보인다. 결국 우리도, 어느 순간에는 한 도메인을 담당하는 개발자가 될테니까.
  
</details>  

<br/><br/>



---
## 2022.03.22 TIL
- 다른 사람의 TIL 읽어보기

> [Pleed님의 노션](https://pleed0215.notion.site/TIL-2022-03-20-4ca7872472914687a2f74b7f66b8e477)

- 내용 정리보다도, 뒤의 핵심 키워드별 견해를 모아담은게 가독성도 좋고 마지막 정리? 차원에서 유익하게 읽혔다. 지금은 문맥 - 주석 혹은 소감 한 줄씩 담아내고 있는데, 이 분처럼 정리하는 것도 좋겠다는 생각...? 

> [아직 개발자가 아니라는 Izaak님의 velog](https://velog.io/@corepen_/3%EC%A3%BC-%EC%99%84%EB%8F%85-Daily-%EC%84%9C%ED%8F%89-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8-3) 

- 프로그래밍은 결국 글 쓰는 과정, 명세서를 쓰는 과정이라고 했었는데. 이런 작은 TIL부터 글짓는 관점으로 접근한다면 컨텐츠가 어떻게 풍부해지는지 느낄 수 있는 글이었다. 하나의 책을 새로 재편하는 느낌인데, 글이 길어도 오히려 가독성이 좋아진 느낌이다. 글 쓰기에서도 객체 지향적 사고로 잘 묶어내야하나?

> [(thinking_face)가 인상적인 dy님의 notion](https://intelligent-custard-04a.notion.site/Day-3-7c350ba47e85461c9dd018613ce3b048)

- 노션에서 코드 블록이나 (thingking_face)등을 잘 이용해서 밀도 있는 요약으로 읽혔다. 문단 구분이나 폰트 등 강조 지점을 잘 살려줘서 좀 더 잘 읽히는 듯. TIL의 디자인도 이런식으로 배치를 고민해봐야겠다. 프론트에서 테스팅은 ... 쉽지않네.

<br/>
<br/>


---
## 2022.03.23 TIL
- 3장 기본 도구 

### 책에서 기억하고 싶은 내용 & 메모

> grep은 여러 파일에서 문자열을 찾는 도구다. 과거 ed라는 편집기에서 비슷한 일을 하는 명령이었던 "g/re/p"에서 유래한 이름이다. 여기서 re는 찾고자 하는 정규 표현식을 의미한다.

- 텍스트에서 뭘 움켜쥐는 취지인가? 싶었는데, g/re/p였다니, 지쟈쓰.

<br/>

> GUI의 단점은 WYSIAYG (What You See is All You Get)

```bash
grep `^import ` *.java |\
  sed -e`s/.*import *//` -e`s/;.*$//` |\
  sort -u > list
```

- .java에서 명시적으로 import하는 파일명을 모아 list에 담는 shell 예시라는데, 쉽지 않다.

<br/>

> 별칭과 셸 함수. 만날 사용하는 명령어에 간단한 별칭을 만들어서 작업을 단순화하라.

```bash
alias rm = 'rm -iv'
```
- 신규 개발자의 환경 설정 관련해서 많은 GUI내 상호작용을 아직 요구하고 있는데, 쉘 스크립트 하나짜서 실행토록 해보는 것도 쏠쏠할듯

<br/>

> 마우스, 트랙패드를 치워라.

- 아직 줄단위로 지우는 정도만 손에 익는데, 컴파일 오류나 여러줄 선택 후 알파벳순 정렬은, 이런기능도 있었구나 싶다. 와우에서 매크로 지정하는 감각인데.

<br/>


> 저장소 시스템은 (...) 다음과 같은 기능이 있어야 한다.
>
> - 확실한 보안과 권한 관리
> - 직관적인 UI
> - 명령 줄에서도 모든 작업 수행 가능
> - 자동화된 빌드와 테스트
> - 브랜치 병합 (Pull Request)을 잘 지원
> - 이슈 관리
> - 적절한 보고서 기능
> - 원활한 팀 의사소통 지원

- 제발 수동으로 jar 옮긴다는 문서를 이젠 그만 보게 해줬으면.
  
<br/>

> 프로젝트 이외의 것에도 버전 관리를 사용하라.

- 사내 회의록이나 주간보고 등에도 요새는 버전관리 스러운 기능이 쓰이고 있으니, 이런 맥락 아닐까.
- 개인적인 기록도 요새는 로컬 git 설정을 하고 로그를 뜯어보고는 있다.

<br/>

> 하지만 기술의 전당에서는, 남을 비난하기보다 문제를 고치는 데에 집중해야 한다.

- 버그를 찾아내면 만든이를 비난하는데 시간쓰지말고, 고치는데 시간쓰자는 취지. 생각보다 중요하고 또 중요하다.

<br/>

> 버그를 고치는 첫 걸음으로 가장 좋은 것은, 그 버그를 재현할 수 있게 만드는 것이다.

<br/>

> 스택 프레임을 일일히 조사하는것보다 더 빠른 방법이 있다. 바로 이진 분할을 하는 것이다.

- 와, 왜 이생각을 못했을까. 당연히 완전탐색한다는 마음으로 인간 dfs가 되어가던 내가 멍청했다.

<br/>

> select는 망가지지 않았다.

- 단 하나만, 내가 무언가 변경했는데 시스템이 이상이 있다면 대개는 변경한 코드가 문제임을 겸허하게 받아들이자.
- 오히러 업그레이드를 미루고 싶다는 니즈는 지구 공통이었다. 제공되는 함수나 API가 달라지니 어쩔 수 없지.

<br/>

> 엔지니어링 일지를 남겨 보라. (...) 적어도 훗날 성공해서 유명해졌을 때 회고록을 쓰는 데 도움이 될 것이다.

- 우리는 틀리지 않았다.

<br/>

### 결론 - 오늘의 소감
<details>
  <summary> 장인은 도구를 안 가린다고? </summary>
  
  - 간혹 장인은 도구를 안가린다며 수년전 설정의 이클립스를 그대로 받아 쓰라는 회사를 본적이 있었다. 회사 내 안좋은 문화를 개인의 문제로 치환시키는 기적이란. 
  일단 개발환경의 최적화와 도구를 날카롭게 구비하는 건 개발자의 몫임을 다시 되새겨본다.
  
  - 버그 재현에 대한 개념이나 엔지니어링 일지까지. 생각한 개발 지향적인 문화가 그대로 녹아 있어서 마음이 든든해졌다. 

  - 이진 탐색.

</details>
<br/>
<br/>

---
## 2022.03.24 TIL
- 4장 실용주의 편집증

### 책에서 기억하고 싶은 내용 & 메모

> 불완전한 시스템, 어림도 없는 기간, 우스꽝스러운 도구, 불가능한 요구 사항으로 가득 찬 세상에서 안전하게 살아 보자

- 가능과 불가능의 영역에서 적절한 검증을 하며 대처하자는 제언. 합리적인 수순인듯하다.

<br/>

> DBC : Design By Contract - 계약에 의한 설계

<br/>

> DBC는 테스트 환경 구성이나 목mock이 필요 없다.

- 앞에 나온 코드를 보니 어딘가 클린코드의 컨셉과 충돌한다고 생각이 들었는데, 이런 맥락에서 냄새가 난게 아닌가 싶다.

- 앞의 accept_deposit의 크기에 따른 guard절 삽입도, 객체지향 관점에서의 접근과도 거리가 있고 생각보다 소스가 길어진다.

- guard절은 단일 책임 원칙을 위배하나?

<br/>

> TDD는 멋진 기법이다. 하지만 다른 많은 기법과 마찬가지로 '정상 경로'에만 집중하도록 유도하기도 한다.

- 데이터가 비정상인걸 방지 하기 위해 빈 list를 기본값으로 주는 등, 다양한 방어적 기법이 있음을 알고 있다. Test 케이스의 작성 수도 제한적일 수 있으니, 어느 정도 정상경로만 포커싱한다는 것도 납득은 되는데...

- 결국 모든 함수 구현은 input에 대한 validation을 거쳐야 한다는 취지인가? 그럴지도 모르겠다.

<br/>

> 여기서 아무 인자 없이 쓴 raise는 현재 예외를 다시 발생시키는 것이다

> 실용주의 프로그래머라면 다음과 같이 쓸 것이다.

```python
add_score_to_board(score)
```
- try~ catch~ finally에 대한 언급은 클린코드에서도 있었다. 여기서는 불필요한 캐치 하느니 상단에서 잡는게 낫다는 취지인데.
- 에러 코드를 정의하고 로그를 찍는것보단 error를 올리는게 낫다는 취지와 이어지는 것으로 이해된다. 

<br/>

> 단정은 결코 일어나면 안 되는 것들을 검사한다.

> 두 가지 명백하게 틀린 가정이 있다. 첫째, 테스트가 모든 버그를 발견한다는 가정이다.

- TDD의 본질을 관통하는 질문이다. 안되는 케이스를 먼저 작성해서 코드를 빠르게 디벨롭하는 기법이, 모든 오류케이스를 탐지한다와는 다르긴 하지.

<br/>

> 일부 자바 개발자의 변수 사용 후 null로 설정이 좋은 이유 : 객체를 가리키는 포인터의 수가 하나 줄어든다. 포인터 갯수가 0개가 되면? 가비지 컬렉션의 대상.

- 불필요한 사용 후 초기화 과정인 줄 알았는데 매우 가치가 있는 일이었구나.

<br/>

> 이 책의 1판이 나올 무렵 컴퓨터 잡지와 올라인 게시판을 달군 주제는 (...) 모티프인가 오픈룩인가 였다? 승자는 브라우저 웹이 빠르게 중원을 평정했다.

- 신기술의 방향을 예측하는게 얼마나 덧없는지 보여주는 부분인 듯하다.

- 요새는 어지간한 회사의 내부 시스템도, 윈도우 어플리케이션이 아닌 웹서비스로 제공 중이니... 보안의 구획화 관점에서는 좀 더 편리할지도 모르겠다.

<br/>


메일로 흥미로운 내용이 와 있었다!
[victoria yang](https://ilpyoyang.tistory.com/218)
단정문을 사용해서 불가능... 예제 유의.

- 인풋 검사로 assert쓰라고 이해했었는데, 사실 관점은 일어나면 안되는 일이었다.


### 결론 - 오늘의 소감

<details>
  <summary> 코드를 키워 나갈때는 TDD, 실제 운영 반영할 때는 방어적인 프로그래밍 </summary>

- 연습문제 16 내용이 매우 인상적이었다. 한 달이 28일 보다 적을 수 있구나...?

- 매번 한달의 크기를 체크 하는건 불필요한 소모일 수는 있지만, 언제고 발생할 에러의 원인이 될 수는 있겠다. 

- 한쪽은 테스트 케이스, 단위 테스트를 많이 쓰자고 주장한다면 여기선 코드 내에 assert를 많이 삽입해두자가 메인 컨셉인 것으로 보인다.
서버 자원이 충분만 하다면, 어플리케이션 성능 보장 한도 내에서는 납득이 된다.

- 어떤 개발 방법론이 좀 더 효과적인가, 효율적인가 고민이 되는 시점이다. TDD는 빠르게 증식하는 코드를 철사로 방향을 잡아주는 느낌이었는데, 여기는 뭐랄까. 이런 사례, 저런 사례도 있으니 항상 측정자를 들이밀고 가지쳐주자는 느낌이다.

</details>
<br/>
<br/>




---
## 2022.03.26 TIL
- 5장 실용주의 편집증

### 책에서 기억하고 싶은 내용 & 메모

> 결합도가 낮은 코드가 바꾸기 쉽다.
> - 열차 사고 : 연쇄 메서드 호출
> - 글로벌화 : 정적인것의 위험함
> - 상속 : 클래스 상속도 위험함.

<br/>

> 무언가에 접근할 때, "."을 딱 하나만 쓰려고 노력해보라.

- 성급한 특정 객체의 메서드로 만드는 것보단, 하기 파이프라인 형식으로 처리하는 것을 권장하고 있었다. 

> 결국은 모두 ETC

<br/>

> 이벤트를 처리하기 위한 4가지 전략
> - 유한 상태 기계
> - 감시자 패턴
> - 게시-구독
> - 반응형 프로그래밍과 스트림

- 여긴 꼭 기억해두자. 게시-구독은 정말 많이 봐온 모습.


> 감시 대상이 직접 콜백 호출 할 경우 병목 가능 -> 이 문제는 '게시-구독'으로 해결한다.

> 스트림은 이벤트를 일반적인 자료 구조처럼 다룰 수 있게 해준다.

> 이벤트 스트림은 비동기 컬렉션

<br/>

> 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고방식으로 돌아갈 필요가 있다.

- 객체주의 프로그래밍의 '객체'라는 단어가 주는 환각에서 벗어난 담백한 맥락으로 다가온다. 결국 이벤트 등을 고려한 다양한 인풋 상황에 대해 특정 결과를 내는 것, 이걸 잘 가독성있게 쓸 수 있는지. 이게 프로그래밍의 본질이었다.

<br/>

`find . -type f | xargs wc -l | sort -n | tail -5 ` 

`find . -type f | xargs wc -l | sort -n | tail -6 | head -5`

- 가장 긴 파일 뽑아내기.
- 현재 디렉터리에서 file 찾고 > wc -l의 인자로 넘긴뒤 > 정렬하고 > 다섯건.

> x 언어에는 파이프라인이 없는데요 -> 변환 프로그래밍은 설계 철학일 뿐이고, 임시 변수에 값을 담아둔다고 이해할 것

```javascript
const content = File.read(file_name);
const lines = find_matching_lines(content, pattern);
const result = truncate_lines(lines);
// content | lines | result 같은 데이터 플로우.

```

<br/>

> 변환 모델의 결합은 객체 지향 방식의 지휘 및 통제보다 훨씬 관리하기 쉽다.

- 제한된 범주내의 데이터가 들어올 경우 B처럼 처리하라 > 다시 데이터를 넘긴다와 같이, 보다 직관적인 면이 있다.

- 하지만 객체 지향이 왜 대두 되었나 생각해보면, 변화에 과연 유연하게 대응할 수 있나는 의문이다. 상기 예제의 find_matching_line 정보가 변한다던지, content의 상세가변화(갑자기 double_space가 표준이 된다던지) 할 경우, 전체 파이프라인에 대해 검증이 들어가야하지 않나? 특정 지점을 바꾸면 assert로 잡을 순 있겠지만, 저자의 생각보단 결합도가 높다고 생각한다.

<br/>

> 상속을 사용하는가? 아마 여러분에게 필요한 것은 상속이 아닐 것이다.

> 상속도 일종의 결합이다.

- ?! 생각치 못한 부분이었다. 왜 상속이 머릿속에서 복잡하게 해석되지 하고 돌이켜보니, 상속의 용도가 두 가지 측면인게 하나, 그리고 하나의 결합처럼 해석된다는게 둘이었구나. 솔직히 List ~ = ArrayList<>를 매번 잡아주면서, ArrayList를 쓰고 싶을 뿐인데 왜 그 위의 List를 자꾸 바라봐야 하는지 의문이긴 했었지. 결국 개발자의 머릿속에 하나의 결합 체계를 두는 꼴이었다.

> vehicle이 변수 이름을 바꾸자... 어느새 Car이 망가졌다.

- 인터페이스를 쓰는 이유는 이런 임계점을 확인하기 위해서가 아니었을까. 그럼에도 vehicle과 같이 부모계층을 바꾸는 것은 매우 조심스러워지고, 그러다보니 손자까지 만드는거 같다. car에는 다시 truck을 만들어서, vehicle과 truck사이의 관계는 높은 결합을 갖지만 추적하기 어려워지지 않을까.

<br/>

> 서비스에 위임하라. Has-A가 Is-A보다 낫다.

<br/>

> 외부 설정으로 애플리케이션을 조정할 수 있게 하라

> - 데이터베이스, 외부 API 인증
> - 로그 레벨, 로그 저장 위치
> - 애플리케이션이 사용하는 포트번호, IP주소, 기계/클러스터이름
> - 특정 실행 환경에만 적용되는 검증 매개 변수
> - 외부에서 지정하는 매개변수
> - 지역별 서식
> - 라이선스 키 

<br/>

> 도도 코드를 작성하지 말라

<br/>
<br/>
### 결론 - 오늘의 소감

<details>
  <summary> 프로그램은 데이터 또는 인풋을 정제해 나가는 과정임을 잊지 말아야겠다. </summary>
  
  - 파이프라인을 보니 처음 프로그래밍에서 장벽을 느낀 운영체제 수업들이 떠오르는 순간이었다.
  
  - 그러나 프로그래밍의 본질은, 객체 지향 측면의 읽기 쉬운 코드 작성, 객체라는 개념에 앞서 데이터를 인풋에서 아웃풋까지 도달케 하는 과정이었다.
  
  - clean code에서 parameter은 적을 수록 좋다의 배경지식이 여기가 아닐까. 결국 a라는 데이터를 받아 처리하는 과정이고, 여기에 데이터가 많다는 것은 변환적 프로그래밍에서 벗어나 개발자의 마음이 복잡해져있음을 의미한다.
  

</details>
<br/>
<br/>

---

## 2022.03.28 TIL
- 연습 문제 선택 및 풀이

5장까지의 연습문제 23개 중, 한 문제를 골라 풀이과정을 작성해 볼 것!

> 연습 문제 18
> 일부 자바 개발자들은 어떤 객체를 사용한 다음에는 반드시 그 객체를 가리켰던 변수를 Null로 설정한다. 왜 이것이 좋은 생각일까?

- 어떤 객체의 생성 및 사용 후, 사용 되지 않는 시점에 자동으로 garbage collecting 되기까지 메모리를 점유하기 때문으로 생각한다.
  
- Java 프로그램은 bytecode로 컴파일 된 뒤, Java Virtual Machine에서 구동되고, 이 때 JVM의 heap memory에 객체가 생성된다. 
  이 객체가 해제되지 않는다면, JVM의 GC 전략에 따라 generation 별 gc를 수행해야 한다. 만약 nul로 바꾸지 않은 객체가 살아남아 Old generation으로 이동 된 경우, 이는 heap메모리의 major gc까지 점유를 의미한다. 그렇지 않더라도, java의 gc는 stop the world 방식으로 young generation을 빈번하게 gc하더라도 application의 효율은 떨어질 것이다.

> 정답지 : null로 설정 시 객체를 가리키는 포인터의 수가 줄고, 포인터 갯수가 0이 되면 그 객체는 gc의 대상이 된다.
* string pool과 유사한 감각인듯 하다. 변수가 가리키는 객체라는 말이 쉬이 와닿지 않는다.

> 정답지 : 실행 시간이 길어서 메모리 사용량이 시간이 지남에 따라 늘어나지 않도록 신경 써야 하는 프로그램 이라면 변수에 Null을 설정하는 것이 중요할 수 있다.
- 결국은 heap 메모리 점유율인 것 같다. c대비 자체적인 gc가 있다는 점에서 보다 유연한 것으로 보인다.
- c언어의 경우 runtime error 에대한 지적이 있네. 

참고 문서 : [freecodecamp](https://www.freecodecamp.org/news/garbage-collection-in-java-what-is-gc-and-how-it-works-in-the-jvm/#:~:text=Java%20Garbage%20Collection%20is%20the,memory%20dedicated%20to%20the%20program.) 


### 결론 - 오늘의 소감

<details>
  <summary> 자바는 왜 강인해지는가. 자동화 된 gc, 그리고 이 알고리즘의 고도화 가아닐까.</summary>
  
- 이하 생략. 자바는 생각보다 편하다. 장황하긴해도.

</details>

<br/>
<br/>

---
## 추신.
`#노마드코더 #노개북 #노마드북클럽 #실용주의 프로그래머 #TIL`

