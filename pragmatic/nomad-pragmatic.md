# The Pragmatic Programmer

## 개요
- 노마드코더에서 함께 진행한 책읽기 (TIL)
- 2022.03.19 ~ 
- 

## Table of Contents

> [#1 서문 ~ 1장](#20220319-til)

> [#2 2장]




---
## 2022.03.19 TIL
- 서문 ~ 1장 실용주의 철학 

### 책에서 기억하고 싶은 내용 & 메모

> 왜 코드가 메리의 컴퓨터에서만 빌드되는 거죠?(2판 서문)

- 세상은 넓고 지구는 공평했다. 왜 모두 같은 고민을 하는 거죠? 하며 되묻고 싶은 장면인데. 사실 jdk라는 이름에 맞게 ci/cd툴도 함께 공급(?) 되는게 맞지 않나 싶긴하다. github도 ms에서 인수한 마당에.

<br/>

> 여러분은 매일 작은 기적을 만드는 것이다. 참 어려운 직업이다. (1판 서문)

- 작업에 대한 안내, 사용자를 고려한 설계, 프로젝트 일정 준수 등. 모든 애환이 여기 엿보인다.

<br/>

> 당신은 당신의 조직을 바꾸거나, 당신의 조직을 바꿀 수 있다. (3p)

- 일단 새겨두자. 원격 근무가 안된다면 다른 곳을 가라는 글도 눈에 띈다. 메모.

<br/>

> 소프트웨어 엔트로피
<br/>

> - 깨진 창문을 내버려 두지 말라

- 왜 쿼리를 이렇게 구성해놨는지, 프런트 소스는 왜 항상 미묘하게 차이나는 템플릿을 프로젝트 착수시기마다 버전을 다르게 불러오는건지, 궁금하곤 했다. 하나씩 보자마자 고쳐나가야지.

<br/>

> 시작 피로 (start-up fatigue)

- 프로젝트 하나 하기까지, 그리고 종료하기까지 필요한 코스트가 크긴 하다. 협업 요청보다 절차의 간소화를 요청해야겠다.

<br/>

> 오늘의 훌륭한 소프트웨어는 많은 경우 환상에 불과한 내일의 완벽한 소프트웨어보다 낫다 (17p)

- TDD의 개발 순서, agile에서 가장 간단한 프로토타입부터 하나씩 고도화 해나가는 맥락을 보는듯하다. 모든 프로그래머들이 같은 이야기를 하는 데에는 이유가 있겠지.

<br/>

> 기능 블로트 : 소프트웨어가 쓰는 기능에 비해 많은 기능을 가지고 있고, 그에 따라 버그나 취약점이 생길 가능성이 높아지는 것

<br/>

> 목표 :
> - 매년 새로운 언어를 최소 하나는 배워라
> - 기술 서적을 한 달에 한 권씩 읽어라
> - 수업을 들어라
> - 지역 사용자 단체나 모임에 참여하라

- 언어 학습이나 기술 서적에 다소 부족함이 있었는데, 분발해야겠다.
- 지역 사용자 단체..는 웹으로 대체 가능한거겠지? 그래도 주말에 간소히 모여서 소규모 프로젝트를 하는 집단은 필요한 느낌이다.

<br/>

> Five Whys.

- 이걸 여기서 또 보네. 햄버거 하면 Five guys인데.

<br/><br/>

### 오늘 읽어본 다른 사람의 TIL

- 1장 : https://velog.io/@ohdowon064/%EB%85%B8%EA%B0%9C%EB%B9%84-pragmatic-1%EC%9E%A5.-%EC%8B%A4%EC%9A%A9%EC%A3%BC%EC%9D%98-%EC%B2%A0%ED%95%99
  - 책임감 중요하지. 암암.

- 1장 : https://proamateur92.tistory.com/68
  - 커뮤니케이션 방식에 대한 고민선이 같았다...! 실무자의 그 무언가가 느껴진다.

<br/><br/>

### 결론 - 오늘의 소감
<details>
  <summary> 햄버거는 five guys, 방법론은 five whys. </summary>
  
  - 우리는 왜 회사의 IT 부서와 IT 회사간의 차이와 벽을 느끼는지 디테일이 보이는 대목들이었다.
  
  - 개발자라는 특정 직업군의 한 끝단에서 머무르는게 아니라, 프로젝트의 관리자로서 마음가짐을 엿보게 해주는 느낌. 
  
  - 클린 코드보다는 조금 더 사회생활 풀이 같긴 한데, 아직 일련의 불안함이 앞선다. 이 책이 나에게 도움이 될까, 내 부서의 다른 사람들에게 도움이 될까.
  
  - 햄버거는 five guys, 방법론은 five whys. 그런데 six sigma 시대의 방법론 아닌가 걱정은 살짝 된다만서도.
  
</details>

---
## 2022.03.21 TIL
- 2장 실용주의 

### 책에서 기억하고 싶은 내용 & 메모

> 좋은 설계는 나쁜 설계보다 바꾸기 쉽다. (...) 그래서 우리는 ETC 원칙을 따른다. Easier to Change. 

- 어떤 설계가 보다 뛰어난가는 바꾸기 쉬움에 있었다. 클린코드에서 코드 가독성, 응집도를 낮춰서 biz변경시의 유연한 대응과 맥이 닿는 부분.

<br/>

> DRY 원칙은 다음과 같다. `모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.` Don't Repeat Yourself

- 권위 있게라는 표현이 참신했다. 그만큼 해당 코드에 대해 깊이 고민하고 반영하라는 취지 아닐까.

<br/>

> 이제 숫자 형식을 바꿔야 하면 format_amount를 바꾸면 되고, 항목 이름 형식을 바꾸고 싶으면 report_line을 바꾸면 된다.

```c++
def format_amount(value)
  result = sprintf("%10.2f".value.abs)
  if value <0
    result + "-"
  else
    result + " "
  end
end

def print_line(label, value)
  printf "%-9s%s\n", label, value
end

def report_line(label, amount)
  print_line(label + ":", format_amount(amount))
end

def print_balance(account)
  report_line("Debits", account.debits)
  report_line("Credits", account.credits)
  report_line("Fees", account.fees)
  print_line("", "---------")
  report_line("Balance, account.balance)
end
```

- cleancode에서는 책의 예제와 같은 작위적인 포맷-라인정렬이 구닥다리- 본문은 account.{methods}를 탭으로 정렬함 - 라고 하긴 했는데, 그래도 코드에서 중복을 줄이는 발상이 인상 깊었다.

- 하지만 코드가 좀 장황해지지 않나 생각은 든다. 첫 코드는 순차적으로 이런 동작들을 하겠구나 읽혔다면, 마지막 코드는 각각의 함수가 어디에서 쓰이지 하고 지면을 오가며 읽어야하는 불편함이 있다. 만약 Java였다면 선언부와 사용부를 도치시켜서 조금 더 가독성이 좋았을지도 모르겠다.

- 혹은 account라는 객체 정의 > account.print_balance(format) 정도로 재구성하는게 좋지 않을까? 

<br/>

> 모든 코드 중복이 지식의 중복은 아니다.

- 이어나온 사례에서 validate(args) 로 구성하면 어떨까 싶었는데, 다시 validate에서 age인지 quantity인지 확인하고 각각 함수를 작성해줘야 하는 점을 간과했었다.

- 그렇다고 args.validate와 같이 구성하면, 객체 마다 validate를 정의해야하니.. args를 interface또는 추상클래스로 만들어서 validate를 재정의하게 해야하는데, 무엇이 ETC에 적합한지는 모호하다고 생각한다. 아직은 규모가 작으니 독립적인 두 개의 메소드로 구현하는게 맞을지도?

<br/>

> 개발자 간의 중복에 대처하려면 크게는 의사소통을 잘하는 튼튼하고 유대가 돈독한 팀을 만들어야 한다.

- 어느 정도의 부분에서 중복으로 인한 비용 < 개발자간 소통비용이 되어 중복이 용인되는걸까? 정산에서 자릿수 검증과 기온 체크에서 자릿수 검증은 같은 모듈을 써야하나?

<br/>

> 컴포넌트들이 각기 격리 되어 있으면 어느 하나를 바꿀 때 나머지 것들을 걱정하지 않아도 된다

- 단일 책임 원칙과 맥이 닿는 부분으로 이해된다.

<br/>

> 다중 상속과 다중 인터페이스 사용이 직교성에 끼치는 영향이 다른가?

- 오버라이딩 관점에서 다중 인터페이스를 우려한 글은 보았는데, 쉽지 않다. 다른가?

<br/>

> 외부의 API를 여러분이 만든 추상화 계층 뒤로 숨겨라

- DB Connection도 한층 추상화하고 도메인 언어를 만든 것을 생각하면, 이게 맞는 방향으로 생각된다. 장황하지 않은가는 그 뒤의 문제 아닐까.

<br/>


> 사업 부서 사람들은 달성하려는 목표에 대해 두루뭉술한 생각만 갖고 있을 뿐, 세부사항에 대해서는 알지도 못하고 신경도 안 쓴다.

- 이걸 마음에 새겨 두자. 모르니까 소통이 안되는 것이고, 우리의 가치는 여기에 형태를 부여하는 것이었다.

<br/>


> 추정치는 어디에서 나오는가? (...) 이미 그 일을 해본 사람에게 물어보라

- 생각보다 멀쩡한 개발자로 살아남으려면 개인간의 커넥션이 중요했다. 앞에서는 끈끈한 팀, 뒤에서는 이미 그 일을 해본 사람.

<br/>

> 누군가 추정해 달라고 하면 뭐라고 대답해야 할까? 나중에 연락드릴게요. 라고 말해야 한다.

- 수평적이고 소통이 빠른 회사에서 생각되는 가장 이상적인 시나리오인 것 같다. 물론 담당자가 급하다고 이상한 추정치를 내면, 2주 뒤 임원보고 까지 올라가 있는 자신의 추정치를 볼 수 있긴 하지만.


<br/><br/>

### 오늘 읽어본 다른 사람의 TIL



<br/><br/>

### 결론 - 오늘의 소감
<details>
  <summary> Easier to Change </summary>

  - 개방-폐쇄 원칙과 충돌하나 오해했지만, ETC라는 가치 기준을 잘 따라가는, 구현하는 방식이 Open-close Principle 이라고 결론 내렸다. 가장 쉬운 방식의 기능변경이 가능한 코드는, 모듈화가 잘되어 새로 추가만 하면 되는 코드였다.
  
  - 끈끈한 개발자 팀은 정말 쉽지 않아 보인다. 내가 쓴 코드를 자신있게 오픈하는 문화가, 기업의 회사원으로서의 문화와는 충돌할 수 있지 않나? 프로젝트 사서는 조금 더 실용적인 아이디어로 보이지만, 명칭이 아닌 실제 역할로 이어지기에는 시간이 필요해보인다.
  
  - 내 소스를 자유롭게 올리고 리뷰 받는 것과, 팀 내에 이미 그 일을 해본 사람에게 물어보고 추정치를 내리는 것에는 긴 간극이 있다. 요즘은 개발 마저 인싸가 가져가는 시대인가? 어렵다.
  
  - 개발자 보다는 프로젝트의 관리자 혹은 리더, 그 어느 사이에 있는 이들에게 실천적인 방법들로 보인다. 결국 우리도, 어느 순간에는 한 도메인을 담당하는 개발자가 될테니까.
  
  
</details>  

<br/><br/>
---

## 추신.
`#노마드코더 #노개북 #노마드북클럽 #실용주의 프로그래머 #TIL`

