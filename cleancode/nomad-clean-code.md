# Clean code TIL,
with Nomadcoder :p
<br/><br/>

- 개요 : clean code TIL
- 시작 : 2022.02.18 ~ 
- 종료(예정) : ?!
<br/><br/>




## Table of Contents
---
* [Assignment 0 - 사전 준비](#abstract)
* [Assignment 1 - 깨끗한 코드](#chapter-1-clean-code)
* [Assignment 2 - 의미 있는 이름](#chapter-2-name)
* [Assignment 3 - 다른 TIL 살펴보기]
* [Assignment 4 - 함수](#chapter-3-function)
* [Assignment 5 - 주석](#chapter-4-comment)
* [Assignment 6..? - 형식 맞추기](#chapter-5-format)
* [Assignment 7..? - 객체와 자료구조](#chapter-6-object--data-structure)
* [Assignment 8..? - 오류 처리](#chapter-7-error-handling)
* [Assignment 9..? - 단위 테스트](#chapter-9-unit-test)
* [Assignment 10..? - 클래스](#chapter-10-class)

## Chapter 1 Clean Code
--- 
> 2022.02.19


### 기억 및 메모
> 궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다 (3p)
- 잘 작성된 코드는 가독성이 높다는 맥락과 연결되는 대목 아닐까.
 

> 르블랑의 법칙(leblanc's Law) - 나중은 결코 오지 않는다(4p)
- 프로젝트의 기간, 소스 반영전의 이해관계자를 오가며 검토할 경우 더더욱 그러는 듯 하다.
- 개발 반영 프로세스에서도 좀 더 기민한 대응이 가능해야하지 않나?


> 새로운 타이거 팀이 구성된다. (5p)
- si / sm의 현장을 보여주는 대목이라 다시 봐도 인상깊다. 세계와 현장을 아우른다니.


> SRP, OCP, DIP (19p)
- SRP : [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle) - 단일 책임. 한 클래스는 하나의 책임만.
- OCP : [Open Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) - 확장에는 개방정이지만, 변경에는 폐쇄적.
- DIP : [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle) - 응집 대신 추상화를.
! SOLID principle의 일부. 유의할 것

<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 다시 읽어도 도입부의 프로젝트 내부 묘사가 사실적이다. 타이거 팀은 과연 몇 년 걸려서 기존 기능을 커버하는 뛰어난 시스템을 만들까.
  
 - 대개는 마이그레이션이라며 병행 사용을 안고 가더라. 대체가.

 - 샘플 코드를 다른 언어로 작성해보며 따라가봄직 싶다. 아니면 예전에 작성한 코드를 발굴해본다던지.
</details>

<br/>
<br/>


## Chapter 2 Name
--- 
> 2022.02.20


### 기억 및 메모
> 문제는 코드의 단순성이 아니라 코드의 함축성이다 (23p)
- 간혹 a의b를 c를참조해서 d인케이스에처리하는 e다 같은 긴 이름의 메소드명은 과연 옳은 것일까? 아니면 분해가 덜된걸까?(class명이라던지)

> 변수 이름에 variable이라는 단어는 단연코 금물이다 (26p)
- 불과 2년전에 v_ , g_, t_로 구분하는 플젝을 본적이 있었는데. 

> 새로운 개발자가 들어오면 변수를 설명해준 다음 ... 우리가 만들어낸 발음을 알려줬다 (27p)
- 하면 안될 사례로 기록. 그러나 한국의 단어 음절을 1)영어로 번역 후 이름 사용 vs 2)한국단어 그대로의 초성만 가져옴의 관습 중, 무엇이 나은지는 의문이다.
- 영어가 모국어가 아닌 이들은 어떻게 변수명을 정립하는게 맞는가에 대한 고민이 필요하지 않을까? 물론 영어모르고 코딩은 무리긴 하더라도, 이름에 대한 규약은 필요할듯하다.

> 검색하기 쉬운 이름을 사용해라(28p)
- 마찬가지로 단순히 한글 명칭을 쓰면 검색하기 편하지 않을까 싶다. 심지어 한국어의 동음이의어를 고려하더라도. 용언에 대한 정립은 고민해봐야될지도
- 현행 영어로 1차 번역 -> 기존 관습적인 변수명과 비교 -> 이후 선언 및 사용하며 생각보다 변수명의 통일성이 줄어드는 듯.

> GSDAccountAddress 클래스를 사용할까? (37p)
- 이런 이름 많이 본 거 같다.
- Address의 구현체로 GSDAddress or GSDAccountAddress도 부적합할까...?


<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 코딩은 영어공부가 절반이라더니, 그 맥락을 이해하는 것은 쉽지 않은 듯하다.
 
 - add, insert, append의 메서드가 각각 선언되었을 때, 정확한 늬앙스의 차이를 구분할 수 있을까? 직관적으로는 add는 연산, append는 리스트의 마지막에 추가, insert는 특정 인덱스에 추가로 생각되지만.. 
 막상 java List의 add는 그냥 하나 추가다.
 
 - 언어 및 이름이 주는 느낌을 다른 이들이 공감되는 선에서 코드에 녹여내는 역량이 클린 코드와 닿지 않나 생각된다.
 
 - 반면 Biz 영역의 용어를 사용하는 것에 대해도 논의가 필요하지 않나 생각된다. a+b의 합을 단순 add / calculate등으로 명시했지만 알고보니 '결산', '정산' 동작이었다면...?
 
</details>


<br/>
<br/>

## Chapter 3 function
--- 
> 2022.02.23
### 기억 및 메모

> 사실 다음 코드로 줄어야 마땅하다 (43p)
```java
public static String renderPageWithSetupsAndTeardowns(
 PageData pageData, boolean isSuite) throws Exception {
 if (isTestPage(pageData))
  includeSetupAndTeardownPages(pageData,isSuite);
 return pageData.getHtml();
}
```
- 통상 앞선 목록2 길이의 코드도 어딘가 불안해서 늘여쓰곤 하는데 (특히 biz에서 몇 테이블 조인/ 날짜 크로스체크시 참사)
- 얼마나 짧게해야하는지 + 함수명과 불필요한 블록 제거의 예제로 기억해두자


> 함수는 한 가지를 해야한다. 그 한 가지를 잘 해야 한다. 그 한가지 만을 잘 해야 한다. (44p)
- 한 가지의 범위를 어디까지 쪼개야 하나는 아직 개발자의 주관 영역인듯 하다.
- 프론트 개발 시 react에서 컴포넌트 단위로 쪼개다가 atom단위로 코드 정리하는걸 생각하면, 가능한 작게가 맞는 방향성인 듯
- 함수 내 섹션 주의할 것

> 함수 당 추상화 수준은 하나로! (45p)

> 목록 3-5는 switch 문을 추상 팩토리에 꽁꽁 숨긴다. (48p)
- 추상 팩토리를 이용해 응집도를 떨어뜨린다는게 무엇인지 바로 이해되는 사례
- A만들기 B만들기 C만들기 => 알파벳 만들기 + 알파벳 팩토리 (A or B or C 리턴)
- '일반적으로 나는 switch문을 단 한 번만 참아준다.' 에 유의하자. switch는 코드가 지나치게 길어지게 만들고 책임을 엮어낸다.

> 서술적인 이름을 사용해라 (49p)
- 여긴 아직 좀 의문. A에게a하고B에게b인걸확인한뒤C에게c하자~ 같은 함수명을 보면 좀 아찔해졌었는데, 더 끔찍한건 어순이 바뀌는 지점이었다.
 - ide가 지원해준다 할지언정, 다양한 개발자들이 오가고 외국어 번역을 한 번 거쳐야 하는 타지의 개발자들이 원활히 변수명을 정립할 수 있을까?

> 함수에서 이상적인 인수 개수는 0개(무항)이다. (50p)
- ml 초기 학습시 파라미터 5,6개씩 넘겨줄때 아찔했던 기억을 생각하니, 맞는 말이다.
- 그러나 모두 상위 class 내의 private 변수로 담아두면, 변수 선언부가 필요이상으로 길어지지 않을까...?
- 출력 인수에 대한 언급 유의. return a를 해야지 public void testMethod(<Class> a){ a = <result>;} 꼴이 되어 담아내면 대참사. 

> 단항 함수는 가급적 피해라 (51p) 
 
> 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다. (53p)
- 다른 코드 둘러보다 보면 제일 많이 보이는 케이스. 
 
> 오류 코드보다 예외를 사용해라! (57p)
- 예외를 올리다 어디서 처리할지 고민하게 되기도 하는데, 바로 다음에 try-catch블록은 별도의 함수로 뽑으라고 안내해준다. 
```java
public void delete(Page page) {
 try {
  deletePageAndAllReferences(page);
 }
 catch (Exception e) {
  logError(e);
 }
 
 > 의존성 자석 유의
 - Error code를 정의한 enum클래스 사용시, 한쪽에서 코드 추가하면 다른 import 하는 곳에서도 모두 확인 필요
 
 > 반복하지 마라! (60p)
 
 > 함수는 그 언어에서 동사며, 클래스는 명사다. (62p)
 - 요구사항을 작성하는 글 짓기의 연장에서 바라보는 시각 유의.
}

```
 
<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 구체적인 지시사항들이 나오니 한결 마음이 편해지는 듯하다.
 
 - 영화 좀비랜드를 최근에 다시 보며 인상 깊었는데, 주인공인 페이스북의 창업자는 본인의 마법 트릭을 들키지 않기 위해 규칙을 정하고 암기하고 다닌다. 일종의 계율인데.
 
 - 본 함수에 대한 계율을 정립해서 작성할 때 마다 어라, 이거 6번 룰을 어겼나? 하며 되짚으면 재밌지 않을까.
 
 
</details>

<br/>
<br/>
 

## Chapter 4 Comment
--- 
> 2022.02.25
### 기억 및 메모

> 주석은 오래될수록 코드에서 멀어진다
- 간혹 언제썼는지 svn으로 변경점 비교직어야 겨우찾는 주석까지. 오래 묵혀둔 주석은 쉰김치보다 쉽지 않더라만은.
- 주석 대상과 주석 내용이 멀어지는 다음 사례도 인상적이었다. 주석에도 관리가 필요함 유의할 것

 
> 코드로 의도를 표현해라!

```java
// bad

// 직원에게 복지 혜택 자격이 있는지 조사한다
if((employee.flags & HOURLY_FLAG) && (employee.age >65))
 
// good 
if (employee.isEligibleForFullBenefits())
```
- java는 장황한 언어라 했던가, 주석의 불필요함은 공감되지만 employee안에 정의되어야 하는 메소드가 우후죽순 추가되는게 우려는된다.
- employee안에 eligible 뿐 아니라, 신청여부가 추가된다면? benefits이 아닌 유사한 다른 '혜택'개념이 추가된다면?
- employee에 대한 가독성/간소화는 어떻게 유지하는게 맞을까.
 
> 좋은 주석
> 
> - 법적인 주석 : 진짜 법. Copyright, 라이센스 제한 등
>
> - 정보를 제공하는 주석 : return 형식 등
>
> - 의도를 설명하는 주석 : 구현 의도
> 
> - 의도를 명료하게 밝히는 주석 : 메소드의 실제 처리 (얘는 // a+b 입니다 라던지
>
> - 결과를 경고하는 주석
>
> - Todo 주석
>
> - 중요성을 강조하는 주석
>
> - 공개 API javadocs
 
- 사실 이 코드는 yyyyMMdd에 ~~가 ~~과제하며 수정함 주석을 진짜 많이봤는데, 그보다는 의도 설명이 맞는 것이었다.
- 앞선 주석은 나쁜 관례인걸까, 아니면 내가 한거니까 건들지 마라는 footprint인걸까.
- Todo 주석은 약간 의외였다. 특히 다수가 공통으로 관리하는 개발 소스에 커밋한다 치면, 이런걸 넣어도 되나 우려되긴하는데.  
 

> 나쁜 주석
> 
> - 주절거림, 동어 반복, 오해의 여지, 의무감에 따른 javadocs삽입,
> 
> - 이력 기록(!), 없어도 되는 내용(이하 기본 생성자입니다 등), 집착적인 표기목적의 잡음
>
> - 위치 표시용 잡음
>
> - 닫는 괄호에 다는 주석 (!)
> 
> - 주석으로 처리한 코드 (!)

- 이력기록에 대해 언급되어있다. 예전에는 바람직 했던 걸로. 반면 형상관리 툴로 소스 단위 이력 추적보다 주석 한줄이 편하지 않나 싶기도 하다.
- 닫는 괄호에 주석달면 누가 보긴하나..? 쉽지않다.
- 주석으로 처리한 코드는 리팩토링이 덜된/ 그러나 진행 기간이 오래된 코드에서 중요한 정보를 담고 있다고 생각한다. 소스 코드관리시스템으로 수십~수백번의 커밋을 거슬러 올라갈게 아니면 얘는 중요하지 않나 싶기도 하고.

 
<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 회사의 주석에 불필요하거나 필요 이상의 여백이 많다는 생각은 해왔는데, 왜 그런지 이유를 여기서 찾을 수 있던 순간이다.
 
 - 다만 소스 형상 관리 툴로는 3년전 퇴사한 옆회사의 a모씨 이름을 발견하는게 한계가 아닌가 싶다. 프로젝트 투입 시점을 우회하여 간파 가능한 현행의 주석은 나름 쓸모가 있을지도 모르겠다.
 
 - 결국 개발자들이 책임 회피를 위해 주석을 쓰는지, 유용한 정보를 남겨두기 위해 주석을 쓰는지 목적에 따라 갈리는게 아닐까. 주석은 개발자 문화를 보여주는 투명한 진실의 방이라는 생각이 든다.
 
 </details>

<br/>
 <br/>
 
## Chapter 5 Format
--- 
> 2022.02.28
### 기억 및 메모 

> 500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다는 사실(97p)
- 백엔드만 말한걸까? 컴포넌트로 잘 분해하기 전의 html/ js /html안에 script영역은 마냥 그렇진 않은것으로 기억한다.
- 리액트가 새로운 산업 표준이 된다면 괜찮아 질지도 모르겠다.
 
> 몇가지 그라운드 룰
>
> - 신문 기사처럼 작성해라
>
> - 개념은 빈 행으로 분리해라
>
> - 세로밀집도 & 수직 거리
>
> - ** 변수는 사용하는 위치에 최대한 가까이 선언한다 **
>  - 긴 함수의 경우 루프 직전에 변수 선언하기도 한다.
> 
> - ** 인스턴스 변수는 클래스 맨 처음에 선언한다 **

- 특정 인스턴스 변수가 한참 나중의 메소드에서만 쓰인다면? 그렇다면 해당 메소드의 내부에서 선언하거나 그러한 메소드들을 묶어 코드 분리하는게 맞을지도 모르겠다.

> - 종속 함수는 세로로 가까이 배치한다. 호출하는 함수는 가능한 먼저 배치한다.
 
- DFS 일까 BFS일까. 본문 예제로는 식별하기 어렵지만, DFS지향인 것으로 생각된다.
 - 다시보니 사이즈가 특정 이상이면, 새로운 파일로 분리해서 import하는게 맞다는 생각이든다.
 
> - 짧은 행이 바람직하다
>
> - 가로 정렬은 별로 유용하지 못하다. 정렬이 필요할 정도로 목록이 길다면 클래스를 쪼개야 한다는 의미다.
>
> - 빈 while,for문도 올바로 들여쓰고 괄호로 감싸두자.
>
> - 팀은 한 가지 규칙에 합의해야 한다. (...) 개개인이 따로 국밥처럼 맘대로 짜내는 코드는 피해야 한다.
 
- 실제로 팀 단위로 개바랗면 좋겠지만, 사람들이 들어오고 나가는 구조에서 이런 형식 관리가 잘 될 수 있을까는 걱정이다.


 
  
<details>
<summary> **오늘의 소감 한 마디** </summary>

- 사실 오늘의 내용은 팀 단위로 형식에 대해 논의를 한번이라도 해보거나, 설정을 팀에서 잡아주며 프로젝트 착수시 크게 걱정할 필요가 없는 부분으로 생각한다.

- 결국 IDE의 역할이 매우 확대대고 있다는 부분이 아닐까. 반대로 소스 push / pull 시에만 이런 형식을 갖추도록 설정된다면 고민을 덜해도 될 분야가 아닌가 싶다.

- 파이썬의 들여쓰기는 조심할 필요가 있다고 생각한다. java에서 단일행의 while /for 로도 암살당하는 마당에. 
 
</details>
 
<br/>
<br/>

 
## Chapter 6 Object & Data structure
--- 
> 2022.03.01
### 기억 및 메모  

- 왜 private 으로 선언해놓고 getter와 setter를 쓰는가에 대한 질문 (118p)
 
> 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다 (119p)

 
> 새 도형을 추가해도 기존 함수에 아무런 영향을 미치지 않는다 / 반면 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다 (121p)
- 앞선 절차적 코드는 area 함수 내부가 지저분하다 생각했는데, shape라는 interface정의시에는 함수추가가 어렵다는 트레이드 오프가 숨어있었다...!

- 만약 인터페이스로 '둘레 길이'를 새로 추가했는데, 이미 앞선 도형이 12개 정도 정리되어있었다면...? 대참사.

- 반면 추상 클래스로 감싸고 필요한 경우만 오버라이딩 하게 한다면 어떨까 싶지만 어떤 도형은 '무게중심'과 같은 메소드가 정의 안되어있다면 이것도 문제다. 
 
> 기차 충돌은 (...) 피하는 편이 좋다 (123p)
- 스트림이나 필터, 빌더를 쓰다보면 자주 보이는 모습이긴한데. 앞선 요소들은 A에 대해 동등한 깊이의 처리를 한다느 공통점이 있지만, 예제처럼 타고 내려가면 식별하기 어렵긴 하겠다.
- 사실 본문 예제처럼 나누어 선언하지 않아도, 주석으로 해설하게 되지 않을까.
 

> **디미터 법칙**은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다(123p)
- 자료를 숨기고 함수를 제공(getter등)
 
> 잡종 구조는 가능한 피해라
> 
> - 절반은 객체, 절반은 자료 구조 
> 
> - 공개 변수나 공개 getter/setter
 
<br/>

> 그렇다면 cxtx 객체에 임시 파일을 생성하라고 시키면 어떨까?
 
```
BufferedOutputStream bos = ctxt.createScartchFilieStream(classFileName)
```
- ctxt에 options라는 객체가 있다면 options에 역할이 너무 크다고 생각하고, 사실 cxtx에 종속된다고 생각한다. (ctxt.option과 para.option은 다르겠지...?)
- 그러나 ctxt에서 임시파일 생성이라는 역할까지 떠안으면, 너무 범위가 커지는게 아닐까 우려된다. 이후 유사한 option들을 기반으로 interface를 새로 짜지 않을까 싶은데. 

> 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때르는 **DTO(Data transfer object)**라 한다.
- DTO의 사전적 정의보다도 주로 사용하게 되는 시나리오(DB정보 -> app.레벨에서 사용 목적 가공시, 첫 진입점)
- 이어지는 빈에 대한 신랄한 비판은 인상적이다.(일종의 사이비 캡슐화다)

 
<details>
<summary> **오늘의 소감 한 마디** </summary>

- 객체 지향을 위한 클린코드였던가, 객체에 대해 좀 더 이야기가 넓어지는 감각이다. 특히 잡종 구조는 생각보다 많이 보였는데 (객체와 자료구조의 혼합 정도는 괜찮지 않을까...?) 좀 더 고민해봐야겠다.
 
- 듣고 보니 어라, 빈에 매몰될 필요가 없긴 하구나. 사실 스프링 관련 서적을 보고 코드를 구현해도 '빈'을 기반으로 구성했을 뿐이지, 실제로는 vo, dto등 데이터가 어느 계층 사이를 이어주는지가 좀 더 중요했다.
 
- 중간에 절차형 프로그래밍과 객체 지향을 비교하다가, 갑자기 어느순간 '자료 구조'라는 용어로 치환되었다. 이게 직관적으로 전달된게 결론부라서 다소 당황했는데, 요점은 객체 지향으로 가능한 맞춰쓰자 아닐까. 
 
</details> 
 
<br/>
<br/> 
 
## Chapter 7 Error Handling
--- 
> 2022.03.03
### 기억 및 메모  

> 오류코드보다 예외를 사용해라 (130p)
- logger에서 다시 에러코드를 미리 정리해둔 표와 비교하는걸 생각하니 끔찍해진다.
- 다만 tryToShutDown()을 재정리하는게, 필요이상으로 장황해지지 않나 생각은 든다. 
- 해당 메소드의 내부에는 다시 3개의 동작을 수행하는데, 단일한 error을 뱉어내면 디버깅할 때 과연 도움이 될까? 메소드의 수만큼 에러의 수를 뱉는거보다, 로거에 한줄 더 쓰는게 편할지도.
 
> try-catch-finally문부터 작성해라


> 확인된 예외가 반드시 필요하지는 않다 (134p)
- 위에서 한 고민을 바로 뒤에서 이어주었다. 꼭 확정적인 에러를 뱉을 필요는 없구나.
 
> 호출자를 고려해 예외 클래스를 정의해라
- Local Port로 한번 감싼게 그정도로 유용한가 살짝 이해가 덜된다.
- 이후 다른 Port가 추가 되었을 때 / 교체할 때는 유용할 것으로 생각된다. acme의 시점에서 오류 발생보다는 localport.open시점에서 에러 확인되는게 추적이 쉽지않을까.
 
 
> 특수사례 패턴
>
> - 클래스를 만들거나 객체 조작을 통해, null인 값을 더하는등 예외가 발생할 수 있는 경우를 정상 동작으로 포괄
> 
> - 식비 계산 프로그램의 null인경우 합산 > 빈 객체 생성(기본 식대)으로 대처
 
 
> null을 반환하지 마라
>
> - 예시 코드에서 둘째 행에 null 확인이 빠졌다는 사실을 눈치 챘는가?

- null 확인 놓친건 식겁했는데, 코틀린으로 넘어가자는 취지인걸까.
- 모든 경우에 대해 null에 대해 안전한 처리 vs null check합시다 vs try~ catch로 감싸둡시다에서, 아마 프로젝트 감수차원으로 null check가 보편화된 것이라 생각든다.
- 대처는 특수 사례 패턴. null 인경우도 정상적인 시나리오면 처리 가능토록 리턴값을 수정하거나 감싸자.
 
 
> 자바에는 Collections.emptyList()가 있다...!
- 직원이 없는지 체크하는 시점이 변경되었을 뿐이지, 유사한 if절은 확인된다.
- getEmployee()에 모아두면 경비 합산에서만 쓰지 않고, 다른 곳에서 확대 적용할 수 있다는 취지로 생각하자.
 
 
> 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다.
- 모든 코드에서 null check를 하느니, null을 넘기지 말도록 정책을 정하자는 맥락으로 읽힌다.
- 결국 정적 분석기를 통해 검사하는게 최선인듯하다.
 
 
 
<details>
<summary> **오늘의 소감 한 마디** </summary>

- null에 대한 분노가 느껴진다. 사실 이는 java의 문제 혹은 제약이라고 보는게 맞지 않을까. 물론 갑자기 NullPointerException보면 아니 이걸 또 체크해줘야돼? 싶긴하지만..
 
- emptyList만 해도, Python의 리스트 사용 하다보면 그러려니 싶은 부분이다. 
 
- 이번 장의 핵심은 한번 감싸고, 빈값 나오는 경우를 정상처리 하고, 나머지는 exception으로 잡아두자 . service layer의 구현 방안에 대한 요약이었다.
 
 </details>
 
 
<br/>
<br/>

## Chapter 9 Unit Test
--- 
> 2022.03.06
### 기억 및 메모   
 
> TDD 법칙 세 가지
> 
> - 실패하는 단위 테스트 작성할 때까지 코드 작성 x
> 
> - 컴파일은 실패 않고, 실행이 실패하는 정도
> 
> - 현재 실패하는 테스트를 통과할 정도로만 실재 코드 작성
 
- 컴파일은 되고 실재 수행 실패는, 함수의 선언과 리턴이 다 알맞게 되어있지만 (int func() => int ) 값 일치 여부등 실재 값이 안맞는 경우 생각하자.
- return 1;  
 
 
> 실재 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다
 
 
> 깨끗한 테스트 코드를 만들려면? 세 가지가 필요하다. 가독성, 가독성, 가독성.
 
 
> Build - operate - check 패턴 유의
- 테스트 자료 생성 -> 자료 조작 -> 결과확인 (assert)
 
> 이중 표준의 본질. 실제 환경에서는 절대 안되지만 테스트 환경에서는 전혀 문제 없는 방식이 있다. (Stringbuffer의 사용 지양 등)
 
> assert구문 수는 최대한 줄여야 좋다 -> **테스트 함수 마다 한 개념만 테스트 하라**
 
- 간소화 하는 규칙은 테스트에도 적용됨 유의. 하지만 함수를 감싸고 중복을 줄이는 것보다, assert 여러 줄이 편리함도 유의. 운영에 들어갈 코드가 아니다!
 
> 테스트의 다섯 규칙
>
> - Fast, Independent, Repeatable, Self-Validating, Trendy
 
- 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안된다에서 마음이 아리다. 
- 독립적인 테스트에는 모킹 / spring에서의 테스트 기법도 포함 되는 말일까? 특정 모듈의 동작 테스트를 하기에는 단위 테스트가 아닌 좀 더 확장된 테스트를 필요로 하기도 했는데, 어떻게 범주를 분해하는게 맞을까 궁금하다.



<details>
<summary> **오늘의 소감 한 마디** </summary>
 
 - 처음 만진 시스템에서는 junit 사용법도 잘몰라서 풀로 테스트를 돌렸던 기억이 새록새록하다.
 
 - 하지만 커넥션 - 데이터 호출 - 해당 데이터의 파싱룰을 확인 하는 시나리오일 때, 어디까지 자동화할지 / 별도의 코드를 작성해 간이 연결을 만들지는 조금 더 설명이 필요하지 않았나 싶었다.
 
 - 결국 거대한 dao, 거대한 biz, 거대한 controller가 아닌 작게 잘 구분된 코드에 대해, 테스트 기법을 알려준게 아닐까 생각된다. 
 
 - 특정 프로젝트 단위에서 테스트 케이스를 사용자 케이스가 아닌, 단위 테스트 케이스로 누군가 방향을 좁혀줘야 실제로 쓰이지 않을까. 결국 개발은 하나의 문화 형성이 보다 중요하다.
 
 </details>
 
 
<br/>
<br/>
 
 
## Chapter 10 Class
--- 
> 2022.03.10
### 기억 및 메모   

> 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다 (172p)
- protected는 왜 쓰나 싶었더니, 가능한 쓰지 말자가 결론이었다. 혹은 테스트 케이스를 위해 작게.
 
> Processor, Manager, Super 과 같이 모호한 단어가 (클래스명에) 있다면, 클래스에 여러 책임을 떠안겼다는 증거이다.
- Manager는 왜인지 간간히 봐왔던것 같다. 단일 책임 원칙 유의하자.
- 예제로 나온 5개의 메서드 정도는 적당하다 생각했는데, 더 쪼개도 디렉토리가 복잡해지는 수순 아닌가 생각은 든다. 
 
 
> 단일 책임 원칙은 클래스나 모듈을 변경할 이유가 하나, 단 하나 뿐이어야 한다는 원칙이다.
- 여태까지 Biz로 몰아왔던 자신과 기존 코드들에 반성하는 시간을 갖자. 그러나 biz, service, controller를 세분화 해서 쪼개는게 필요할까?
- 유사한 기능을 A, B, C Controller에서 다룰때 모듈화해서 빼내는건 복잡도를 키운다고 생각하고, class를 별도로 늘리는건 코드가 지저분해진다고 생각하지만... 어렵다.
  
 
> 많은 개발자는 자잘한 단일 책임 클래스가 많아지면 큰 그림을 이해하기 어려워진다고 우려한다 (176p)
- 나도 그 중 하나고, 하나였다. 총 부품과 시스템의 양은 동등하다는 다음 말이 인상적이다. 사실 IDE의 사용법, 디렉토리나 패키지를 쫓는 방식을 어색할 뿐이었다.
 
 
> 만약 네 변수를 클래스 인스턴스 변수로 승격한다면 새 함수는 인수가 필요없다. 그만큼 함수를 쪼개기 쉬워진다.
- 응집력을 다소 희생하더라도, 함수의 간결성 유지되는 지점 유의.

> sql을 추상클래스로 선언해서 사용하는 예제유의(187p)
- 과거 spring 또는 mybatis기반 우직한 mvc패턴에서 repository로 implement하는 역사를 보는듯하다.
- update를 추가할 때 기존코드와의 독립성이 인상적이다. sql부분만 확인하면된다.
 
 
<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 기존 코드, 그리고 mvc패턴에 묶여있는 자신에 반성해야겠다. 
 
 - 사실 코드 작성은 지극히 결과주의적인 과정이라 생각한다. 결과가 멀쩡하면.. 그사이에 블랙 박스는 중요하지 않아왔고, 이걸 얼마나 더 아름답게 가꿀 수 있는가가 이 책과 프로그래머들의 본질아닐까.
 
 - SQL class를 뜯어고친 장면이 인상적이다. 솔직히 수정 이전 처럼 쓰인 dao class를 정말 많이 봐왔는데, 기존 소스에서 인터페이스 정의를 조심스럽게 사용해왔기 때문일 뿐이었다. 
 
 - 앞선 개발자가 추상클래스 사용을 지양했을때, 혹은 인터페이스 사용을 지양했을 때, 과연 가차없이 사용할 자신이 있을까? 전체를 리팩토링 해야하는 시점에 닥쳤을 때, 어떻게할까 고민해볼 필요는 있다.
 
 - 객체 지향의 개발 원칙들이 사례에서 원칙 도출로 이어져 좀 더 좋았던 챕터다. 어떻게 실무에 적용할지는, 쉽지 않네.
 
 </details>
 
<br/>
<br/>
 
### Memo.
---
#노개북 #노마드 북클럽
...!
