# Clean code TIL,
with Nomadcoder :p
<br/><br/>

- 개요 : clean code TIL
- 시작 : 2022.02.18 ~ 
- 종료(예정) : ?!
<br/><br/>




## Table of Contents
---
* [Day 0 - 사전 준비](#abstract)
* [Day 1 - 깨끗한 코드](#chapter-1-clean-code)
* [Day 2 - 의미 있는 이름](#chapter-2-name)
* [Day 3 - 다른 TIL 살펴보기]
* [Day 4 - 함수](#chapter-3-function)
* [Day 5 - 주석](#chapter-4-comment)
* [Day 6..? - 형식 맞추기](#chapter-5-format)


## Chapter 1 Clean Code
--- 
> 2022.02.19


### 기억 및 메모
> 궁극적으로 코드는 요구사항을 표현하는 언어라는 사실을 명심한다 (3p)
- 잘 작성된 코드는 가독성이 높다는 맥락과 연결되는 대목 아닐까.
 

> 르블랑의 법칙(leblanc's Law) - 나중은 결코 오지 않는다(4p)
- 프로젝트의 기간, 소스 반영전의 이해관계자를 오가며 검토할 경우 더더욱 그러는 듯 하다.
- 개발 반영 프로세스에서도 좀 더 기민한 대응이 가능해야하지 않나?


> 새로운 타이거 팀이 구성된다. (5p)
- si / sm의 현장을 보여주는 대목이라 다시 봐도 인상깊다. 세계와 현장을 아우른다니.


> SRP, OCP, DIP (19p)
- SRP : [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle) - 단일 책임. 한 클래스는 하나의 책임만.
- OCP : [Open Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) - 확장에는 개방정이지만, 변경에는 폐쇄적.
- DIP : [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle) - 응집 대신 추상화를.
! SOLID principle의 일부. 유의할 것

<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 다시 읽어도 도입부의 프로젝트 내부 묘사가 사실적이다. 타이거 팀은 과연 몇 년 걸려서 기존 기능을 커버하는 뛰어난 시스템을 만들까.
  
 - 대개는 마이그레이션이라며 병행 사용을 안고 가더라. 대체가.

 - 샘플 코드를 다른 언어로 작성해보며 따라가봄직 싶다. 아니면 예전에 작성한 코드를 발굴해본다던지.
</details>

<br/>
<br/>


## Chapter 2 Name
--- 
> 2022.02.20


### 기억 및 메모
> 문제는 코드의 단순성이 아니라 코드의 함축성이다 (23p)
- 간혹 a의b를 c를참조해서 d인케이스에처리하는 e다 같은 긴 이름의 메소드명은 과연 옳은 것일까? 아니면 분해가 덜된걸까?(class명이라던지)

> 변수 이름에 variable이라는 단어는 단연코 금물이다 (26p)
- 불과 2년전에 v_ , g_, t_로 구분하는 플젝을 본적이 있었는데. 

> 새로운 개발자가 들어오면 변수를 설명해준 다음 ... 우리가 만들어낸 발음을 알려줬다 (27p)
- 하면 안될 사례로 기록. 그러나 한국의 단어 음절을 1)영어로 번역 후 이름 사용 vs 2)한국단어 그대로의 초성만 가져옴의 관습 중, 무엇이 나은지는 의문이다.
- 영어가 모국어가 아닌 이들은 어떻게 변수명을 정립하는게 맞는가에 대한 고민이 필요하지 않을까? 물론 영어모르고 코딩은 무리긴 하더라도, 이름에 대한 규약은 필요할듯하다.

> 검색하기 쉬운 이름을 사용해라(28p)
- 마찬가지로 단순히 한글 명칭을 쓰면 검색하기 편하지 않을까 싶다. 심지어 한국어의 동음이의어를 고려하더라도. 용언에 대한 정립은 고민해봐야될지도
- 현행 영어로 1차 번역 -> 기존 관습적인 변수명과 비교 -> 이후 선언 및 사용하며 생각보다 변수명의 통일성이 줄어드는 듯.

> GSDAccountAddress 클래스를 사용할까? (37p)
- 이런 이름 많이 본 거 같다.
- Address의 구현체로 GSDAddress or GSDAccountAddress도 부적합할까...?


<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 코딩은 영어공부가 절반이라더니, 그 맥락을 이해하는 것은 쉽지 않은 듯하다.
 
 - add, insert, append의 메서드가 각각 선언되었을 때, 정확한 늬앙스의 차이를 구분할 수 있을까? 직관적으로는 add는 연산, append는 리스트의 마지막에 추가, insert는 특정 인덱스에 추가로 생각되지만.. 
 막상 java List의 add는 그냥 하나 추가다.
 
 - 언어 및 이름이 주는 느낌을 다른 이들이 공감되는 선에서 코드에 녹여내는 역량이 클린 코드와 닿지 않나 생각된다.
 
 - 반면 Biz 영역의 용어를 사용하는 것에 대해도 논의가 필요하지 않나 생각된다. a+b의 합을 단순 add / calculate등으로 명시했지만 알고보니 '결산', '정산' 동작이었다면...?
 
</details>


<br/>
<br/>

## Chapter 3 function
--- 
> 2022.02.23
### 기억 및 메모

> 사실 다음 코드로 줄어야 마땅하다 (43p)
```java
public static String renderPageWithSetupsAndTeardowns(
 PageData pageData, boolean isSuite) throws Exception {
 if (isTestPage(pageData))
  includeSetupAndTeardownPages(pageData,isSuite);
 return pageData.getHtml();
}
```
- 통상 앞선 목록2 길이의 코드도 어딘가 불안해서 늘여쓰곤 하는데 (특히 biz에서 몇 테이블 조인/ 날짜 크로스체크시 참사)
- 얼마나 짧게해야하는지 + 함수명과 불필요한 블록 제거의 예제로 기억해두자


> 함수는 한 가지를 해야한다. 그 한 가지를 잘 해야 한다. 그 한가지 만을 잘 해야 한다. (44p)
- 한 가지의 범위를 어디까지 쪼개야 하나는 아직 개발자의 주관 영역인듯 하다.
- 프론트 개발 시 react에서 컴포넌트 단위로 쪼개다가 atom단위로 코드 정리하는걸 생각하면, 가능한 작게가 맞는 방향성인 듯
- 함수 내 섹션 주의할 것

> 함수 당 추상화 수준은 하나로! (45p)

> 목록 3-5는 switch 문을 추상 팩토리에 꽁꽁 숨긴다. (48p)
- 추상 팩토리를 이용해 응집도를 떨어뜨린다는게 무엇인지 바로 이해되는 사례
- A만들기 B만들기 C만들기 => 알파벳 만들기 + 알파벳 팩토리 (A or B or C 리턴)
- '일반적으로 나는 switch문을 단 한 번만 참아준다.' 에 유의하자. switch는 코드가 지나치게 길어지게 만들고 책임을 엮어낸다.

> 서술적인 이름을 사용해라 (49p)
- 여긴 아직 좀 의문. A에게a하고B에게b인걸확인한뒤C에게c하자~ 같은 함수명을 보면 좀 아찔해졌었는데, 더 끔찍한건 어순이 바뀌는 지점이었다.
 - ide가 지원해준다 할지언정, 다양한 개발자들이 오가고 외국어 번역을 한 번 거쳐야 하는 타지의 개발자들이 원활히 변수명을 정립할 수 있을까?

> 함수에서 이상적인 인수 개수는 0개(무항)이다. (50p)
- ml 초기 학습시 파라미터 5,6개씩 넘겨줄때 아찔했던 기억을 생각하니, 맞는 말이다.
- 그러나 모두 상위 class 내의 private 변수로 담아두면, 변수 선언부가 필요이상으로 길어지지 않을까...?
- 출력 인수에 대한 언급 유의. return a를 해야지 public void testMethod(<Class> a){ a = <result>;} 꼴이 되어 담아내면 대참사. 

> 단항 함수는 가급적 피해라 (51p) 
 
> 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다. (53p)
- 다른 코드 둘러보다 보면 제일 많이 보이는 케이스. 
 
> 오류 코드보다 예외를 사용해라! (57p)
- 예외를 올리다 어디서 처리할지 고민하게 되기도 하는데, 바로 다음에 try-catch블록은 별도의 함수로 뽑으라고 안내해준다. 
```java
public void delete(Page page) {
 try {
  deletePageAndAllReferences(page);
 }
 catch (Exception e) {
  logError(e);
 }
 
 > 의존성 자석 유의
 - Error code를 정의한 enum클래스 사용시, 한쪽에서 코드 추가하면 다른 import 하는 곳에서도 모두 확인 필요
 
 > 반복하지 마라! (60p)
 
 > 함수는 그 언어에서 동사며, 클래스는 명사다. (62p)
 - 요구사항을 작성하는 글 짓기의 연장에서 바라보는 시각 유의.
}

```
 
<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 구체적인 지시사항들이 나오니 한결 마음이 편해지는 듯하다.
 
 - 영화 좀비랜드를 최근에 다시 보며 인상 깊었는데, 주인공인 페이스북의 창업자는 본인의 마법 트릭을 들키지 않기 위해 규칙을 정하고 암기하고 다닌다. 일종의 계율인데.
 
 - 본 함수에 대한 계율을 정립해서 작성할 때 마다 어라, 이거 6번 룰을 어겼나? 하며 되짚으면 재밌지 않을까.
 
 
</details>

<br/>
<br/>
 

## Chapter 4 Comment
--- 
> 2022.02.25
### 기억 및 메모

> 주석은 오래될수록 코드에서 멀어진다
- 간혹 언제썼는지 svn으로 변경점 비교직어야 겨우찾는 주석까지. 오래 묵혀둔 주석은 쉰김치보다 쉽지 않더라만은.
- 주석 대상과 주석 내용이 멀어지는 다음 사례도 인상적이었다. 주석에도 관리가 필요함 유의할 것

 
> 코드로 의도를 표현해라!

```java
// bad

// 직원에게 복지 혜택 자격이 있는지 조사한다
if((employee.flags & HOURLY_FLAG) && (employee.age >65))
 
// good 
if (employee.isEligibleForFullBenefits())
```
- java는 장황한 언어라 했던가, 주석의 불필요함은 공감되지만 employee안에 정의되어야 하는 메소드가 우후죽순 추가되는게 우려는된다.
- employee안에 eligible 뿐 아니라, 신청여부가 추가된다면? benefits이 아닌 유사한 다른 '혜택'개념이 추가된다면?
- employee에 대한 가독성/간소화는 어떻게 유지하는게 맞을까.
 
> 좋은 주석
> 
> - 법적인 주석 : 진짜 법. Copyright, 라이센스 제한 등
>
> - 정보를 제공하는 주석 : return 형식 등
>
> - 의도를 설명하는 주석 : 구현 의도
> 
> - 의도를 명료하게 밝히는 주석 : 메소드의 실제 처리 (얘는 // a+b 입니다 라던지
>
> - 결과를 경고하는 주석
>
> - Todo 주석
>
> - 중요성을 강조하는 주석
>
> - 공개 API javadocs
 
- 사실 이 코드는 yyyyMMdd에 ~~가 ~~과제하며 수정함 주석을 진짜 많이봤는데, 그보다는 의도 설명이 맞는 것이었다.
- 앞선 주석은 나쁜 관례인걸까, 아니면 내가 한거니까 건들지 마라는 footprint인걸까.
- Todo 주석은 약간 의외였다. 특히 다수가 공통으로 관리하는 개발 소스에 커밋한다 치면, 이런걸 넣어도 되나 우려되긴하는데.  
 

> 나쁜 주석
> 
> - 주절거림, 동어 반복, 오해의 여지, 의무감에 따른 javadocs삽입,
> 
> - 이력 기록(!), 없어도 되는 내용(이하 기본 생성자입니다 등), 집착적인 표기목적의 잡음
>
> - 위치 표시용 잡음
>
> - 닫는 괄호에 다는 주석 (!)
> 
> - 주석으로 처리한 코드 (!)

- 이력기록에 대해 언급되어있다. 예전에는 바람직 했던 걸로. 반면 형상관리 툴로 소스 단위 이력 추적보다 주석 한줄이 편하지 않나 싶기도 하다.
- 닫는 괄호에 주석달면 누가 보긴하나..? 쉽지않다.
- 주석으로 처리한 코드는 리팩토링이 덜된/ 그러나 진행 기간이 오래된 코드에서 중요한 정보를 담고 있다고 생각한다. 소스 코드관리시스템으로 수십~수백번의 커밋을 거슬러 올라갈게 아니면 얘는 중요하지 않나 싶기도 하고.

 
<details>
<summary> **오늘의 소감 한 마디** </summary>

 - 회사의 주석에 불필요하거나 필요 이상의 여백이 많다는 생각은 해왔는데, 왜 그런지 이유를 여기서 찾을 수 있던 순간이다.
 
 - 다만 소스 형상 관리 툴로는 3년전 퇴사한 옆회사의 a모씨 이름을 발견하는게 한계가 아닌가 싶다. 프로젝트 투입 시점을 우회하여 간파 가능한 현행의 주석은 나름 쓸모가 있을지도 모르겠다.
 
 - 결국 개발자들이 책임 회피를 위해 주석을 쓰는지, 유용한 정보를 남겨두기 위해 주석을 쓰는지 목적에 따라 갈리는게 아닐까. 주석은 개발자 문화를 보여주는 투명한 진실의 방이라는 생각이 든다.
 
 </details>

<br/>
 <br/>
 
## Chapter 5 Format
--- 
> 2022.02.28
### 기억 및 메모 

> 500줄을 넘지 않고 대부분 200줄 정도인 파일로도 커다란 시스템을 구축할 수 있다는 사실(97p)
- 백엔드만 말한걸까? 컴포넌트로 잘 분해하기 전의 html/ js /html안에 script영역은 마냥 그렇진 않은것으로 기억한다.
- 리액트가 새로운 산업 표준이 된다면 괜찮아 질지도 모르겠다.
 
> 몇가지 그라운드 룰
>
> - 신문 기사처럼 작성해라
>
> - 개념은 빈 행으로 분리해라
>
> - 세로밀집도 & 수직 거리
>
> - ** 변수는 사용하는 위치에 최대한 가까이 선언한다 **
>  - 긴 함수의 경우 루프 직전에 변수 선언하기도 한다.
> 
> - ** 인스턴스 변수는 클래스 맨 처음에 선언한다 **

- 특정 인스턴스 변수가 한참 나중의 메소드에서만 쓰인다면? 그렇다면 해당 메소드의 내부에서 선언하거나 그러한 메소드들을 묶어 코드 분리하는게 맞을지도 모르겠다.

> - 종속 함수는 세로로 가까이 배치한다. 호출하는 함수는 가능한 먼저 배치한다.
 
- DFS 일까 BFS일까. 본문 예제로는 식별하기 어렵지만, DFS지향인 것으로 생각된다.
 - 다시보니 사이즈가 특정 이상이면, 새로운 파일로 분리해서 import하는게 맞다는 생각이든다.
 
> - 짧은 행이 바람직하다
>
> - 가로 정렬은 별로 유용하지 못하다. 정렬이 필요할 정도로 목록이 길다면 클래스를 쪼개야 한다는 의미다.
>
> - 빈 while,for문도 올바로 들여쓰고 괄호로 감싸두자.
>
> - 팀은 한 가지 규칙에 합의해야 한다. (...) 개개인이 따로 국밥처럼 맘대로 짜내는 코드는 피해야 한다.
 
- 실제로 팀 단위로 개바랗면 좋겠지만, 사람들이 들어오고 나가는 구조에서 이런 형식 관리가 잘 될 수 있을까는 걱정이다.


 
  
<details>
<summary> **오늘의 소감 한 마디** </summary>

- 사실 오늘의 내용은 팀 단위로 형식에 대해 논의를 한번이라도 해보거나, 설정을 팀에서 잡아주며 프로젝트 착수시 크게 걱정할 필요가 없는 부분으로 생각한다.

- 결국 IDE의 역할이 매우 확대대고 있다는 부분이 아닐까. 반대로 소스 push / pull 시에만 이런 형식을 갖추도록 설정된다면 고민을 덜해도 될 분야가 아닌가 싶다.

- 파이썬의 들여쓰기는 조심할 필요가 있다고 생각한다. java에서 단일행의 while /for 로도 암살당하는 마당에. 
 
</details>
 
<br/>
<br/>

### Memo.
---
#노개북 #노마드 북클럽
...!
